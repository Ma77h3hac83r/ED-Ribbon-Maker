The project is a Cloudflare‑hosted web app that lets Elite Dangerous pilots log in and, by supplying their personal Inara.cz API key, synchronise in‑game data to generate a virtual “ribbon rack” of achievements. A React 18 + TypeScript front‑end renders each ribbon as scalable SVGs that follow a 32 × 8.22 mm format, with horizontally arranged devices for the Combat, Explorer, Trader, Exobiologist and Mercenary career paths, as well as two alternative designs each for Federal and Imperial Navy ranks. Cloudflare Workers act as the edge back‑end, fetching and normalising commander profiles from the Inara API, issuing JWT session cookies, and exposing JSON endpoints; Workers Cron handles periodic resyncs. Persistent data such as user records and hashed API keys live in Cloudflare D1, fast caches in KV, and any generated image assets in R2, all deployed automatically through Cloudflare Pages with GitHub‑based CI/CD, Sentry tracing and Playwright tests for reliability.

1. front-end stack
react + typescript (next.js "pages + functions" for component-based ui.
tailwind css for styling.
svg-based ribbon components (will be made later).

2. account link & data-sync flow
user creates account/signs in (username/password).
user pastes inara api key - key is stored hashed in the site's database.
cloudflare worker calls inara api endpoint 'https://inara.cz/inapi/v1/' with the key and the 'getcommanderprofile' to get pilot data.
response is normalised and cached, ribbons are then generate on-the-fly.

3. edge/back-end
cloudflare workers
	handle inara api fetches, json normalisation, and sign/verify jwt session cookies.
	provide rest endpoints consumed by react.
cron triggers to refresh each commander's data on login basis.
image generation
	pre-render to png and store in r2 for cdn delivery.

4. data storage
persistent user table (id, inara cmdr id, hashed api key, prefs) - cloudflare d1.
fast key-value cache for recent api response & signed session tokens - cloudflare kv.
large static/generated ribbon images or future user uploads - cloudflare r2 object storage.
per-user sync-state and rate-limit counters - durable objects.

5. authentication & security
cloudflare access.
store only a salted hash of the inara api key; never the raw key.
all worker -> inara traffic sent via https.

6. ci/cd & hosting
source on github; cloudflare pages “pages‑deploy” github action builds and publishes react bundle + worker script on every push to main.
use pages’ built‑in functions folder for lightweight api routes or export the worker as a standalone service.
custom domain, automatic tls, cloudflare analytics and web vitals dashboards out of the box.

7. observability & qa
sentry or cloudflare workers trace for error/latency tracking.
playwright end‑to‑end tests in ci to confirm ribbon rendering and api contract.
use cloudflare logpush (r2/bigquery/s3) if long‑term request logs are required.

8. extensibility hooks
add frontier oauth verification later (users click “authorise frontier” → worker exchanges code for token) while still retrieving detailed stats through inara.
future cqc integration is just another “rank” table in d1 and an additional svg icon.